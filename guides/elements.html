<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Crank.js | JSX, Elements and Renderers</title><link rel="stylesheet" href="/index.css.css"><link rel="shortcut icon" href="/static/favicon.ico"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-20910936-4"></script><script>
								window.dataLayer = window.dataLayer || [];
								function gtag(){dataLayer.push(arguments);}
								gtag('js', new Date());

								gtag('config', 'UA-20910936-4');
							</script></head><body><nav id="navbar" class="navbar"><div class="navbar-group"><div class="navbar-item"><a class="navbar-title-link false" href="/"><img class="navbar-logo" src="/static/logo.svg" alt=""><span>Crank.js</span></a></div><div class="navbar-item"><a class="current" href="/guides/getting-started">Docs</a></div><div class="navbar-item"><a href="/blog/">Blog</a></div></div><div class="navbar-group"><div class="navbar-item"><a href="https://github.com/bikeshaving/crank">GitHub</a></div><div class="navbar-item"><a href="http://npm.im/@bikeshaving/crank">NPM</a></div></div></nav><div id="sidebar" class="sidebar"><h3>Guides</h3><div class="sidebar-item"><a href="/guides/getting-started" class="">Getting Started</a></div><div class="sidebar-item"><a href="/guides/elements" class="current">JSX, Elements and Renderers</a></div><div class="sidebar-item"><a href="/guides/components" class="">Components</a></div><div class="sidebar-item"><a href="/guides/handling-events" class="">Handling Events</a></div><div class="sidebar-item"><a href="/guides/async-components" class="">Async Components</a></div><div class="sidebar-item"><a href="/guides/special-props-and-tags" class="">Special Props and Tags</a></div><div class="sidebar-item"><a href="/guides/lifecycles" class="">Lifecycles</a></div><div class="sidebar-item"><a href="/guides/reusable-logic" class="">Reusable Logic</a></div><div class="sidebar-item"><a href="/guides/working-with-typescript" class="">Working with TypeScript</a></div><div class="sidebar-item"><a href="/guides/custom-renderers" class="">Custom Renderers</a></div><div class="sidebar-item"><a href="/guides/reference-for-react-developers" class="">Reference for React Developers</a></div><div class="sidebar-item"><a href="/guides/api-reference" class="">API Reference</a></div></div><main class="main"><div class="content"><h1>JSX, Elements and Renderers</h1><p><strong>Note:</strong> If you’re familiar with how JSX and elements work in React, you may want to skip ahead to <a href="./components">the guide on components</a>. Elements in Crank work almost exactly as they do in React.</p>
<h2>
				<a class="anchor" name="jsx" href="#jsx">JSX</a>
			</h2><p>Crank is best used with <a href="https://facebook.github.io/jsx/">JSX</a>, an XML-like syntax extension to JavaScript. It is designed to work with transpilers like Babel and TypeScript out-of-box. JSX transpilers work by transforming JSX expressions into <code>createElement</code> function calls. For example, in the following code, the JSX expression assigned to <code>el</code> transpiles to the <code>createElement</code> call assigned to <code>el1</code>.</p>
<pre><code class="language-jsx">/** @jsx createElement */
import {createElement} from &quot;@bikeshaving/crank&quot;;

const el = &lt;div id=&quot;element&quot;&gt;An element&lt;/div&gt;;
// transpiles to:
const el1 = createElement(&quot;div&quot;, {id: &quot;element&quot;}, &quot;An element&quot;);</code></pre>
<p>The <code>createElement</code> function provided by Crank returns an <em>element</em>, a JavaScript object. Elements on their own don’t do anything special; instead, we use special classes called <em>renderers</em> to interpret elements and produce DOM nodes, HTML strings, WebGL-backed scene graphs, or whatever else you can think of.</p>
<p>Crank ships with two renderer subclasses for web development: one for managing DOM nodes, available through the module <code>@bikeshaving/crank/dom</code>, and one for creating HTML strings, available through the module <code>@bikeshaving/crank/html</code>. You can use these modules to render interactive user interfaces in the browser and HTML responses on the server.</p>
<pre><code class="language-jsx">/** @jsx createElement */
import {createElement} from &quot;@bikeshaving/crank&quot;;
import {renderer as DOMRenderer} from &quot;@bikeshaving/crank/dom&quot;;
import {renderer as HTMLRenderer} from &quot;@bikeshaving/crank/html&quot;;

const el = &lt;div id=&quot;hello&quot;&gt;Hello world&lt;/div&gt;;
const node = document.createElement(&quot;div&quot;);
DOMRenderer.render(el, node);
console.log(node.innerHTML); // &lt;div id=&quot;element&quot;&gt;Hello world&lt;/div&gt;
console.log(HTMLRenderer.render(el)); // &lt;div id=&quot;element&quot;&gt;Hello world&lt;/div&gt;</code></pre>
<h2>
				<a class="anchor" name="the-parts-of-an-element" href="#the-parts-of-an-element">The Parts of an Element</a>
			</h2><p><img src="../static/parts-of-jsx.svg" alt="Image of a JSX element"></p>
<p>An element can be thought of as having three main parts: a <em>tag</em>, <em>props</em> and <em>children</em>. These roughly correspond to the syntax for tags, attributes and content in HTML, and for the most part, you can copy-paste HTML into JSX-flavored JavaScript and have things work as you would expect. The main difference is that JSX has to be well-balanced like XML, so void tags must have a closing slash (<code>&lt;hr/&gt;</code> not <code>&lt;hr&gt;</code>). Also, if you forget to close an element or mismatch opening and closing tags, the parser will throw an error, whereas HTML can be unbalanced or malformed and mostly still work. The advantage of using JSX is that it allows you to interpolate JavaScript expressions as an element’s tag, props or children.</p>
<h3>
				<a class="anchor" name="tags" href="#tags">Tags</a>
			</h3><p>Tags are the first part of a JSX element expression, and can be thought of as the “name” or “type” of the element. JSX transpilers pass the tag of an element to the resulting <code>createElement</code> call as its first argument.</p>
<pre><code class="language-jsx">const intrinsicEl = &lt;div /&gt;;
// transpiles to:
const intrinsicEl1 = createElement(&quot;div&quot;, null);

const componentEl = &lt;Component /&gt;;
// transpiles to:
const componentEl1 = createElement(Component, null);</code></pre>
<p>By convention, JSX parsers treat lowercase tags as strings and capitalized tags as variables. When a tag is a string, this signifies that the element will be handled by the renderer. We call elements with string tags <em>host</em> or <em>intrinsic</em> elements, and for both of the web renderers, these elements correspond to actual HTML elements like <code>div</code> or <code>input</code>. As we’ll see later, elements can also have function tags, in which case the behavior of the element is defined not by the renderer but by the execution of the referenced function. Elements with function tags are called <em>component elements</em>.</p>
<h3>
				<a class="anchor" name="props" href="#props">Props</a>
			</h3><p>JSX parsers coalesce the attribute-like <code>key=&quot;value&quot;</code> syntax to a single object for each element, and pass this object to the resulting <code>createElement</code> call as its second argument.</p>
<pre><code class="language-jsx">const myClass = &quot;my-class&quot;;
const el = &lt;div id=&quot;my-id&quot; class={myClass} /&gt;;
// transpiles to:
const el1 = createElement(&quot;div&quot;, {id: &quot;my-id&quot;, &quot;class&quot;: myClass});

console.log(el.props); // {id: &quot;my-id&quot;, &quot;class&quot;: &quot;my-class&quot;}</code></pre>
<p>We call this object the <em>props</em> object, short for “properties.” The value of each prop is a string if the string-like syntax is used (<code>key=&quot;value&quot;</code>), or it can be an interpolated JavaScript expression by placing the value in curly brackets (<code>key={value}</code>). You can use props to “pass” values into host and component elements, similar to how you “pass” arguments into functions when invoking them.</p>
<p>If you already have an object that you want to use as props, you can use the special JSX <code>...</code> syntax to “spread” it into an element. This works similarly to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">ES6 spread syntax</a>.</p>
<pre><code class="language-jsx">const props = {id: &quot;1&quot;, src: &quot;https://example.com/image&quot;, alt: &quot;An image&quot;};
const el = &lt;img {...props} id=&quot;2&quot; /&gt;;
// transpiles to:
const el1 = createElement(&quot;img&quot;, {...props, id: &quot;2&quot;});</code></pre>
<h3>
				<a class="anchor" name="children" href="#children">Children</a>
			</h3><p>As with HTML, Crank elements can have contents, placed between its opening and closing tags. These contents are referred to as the element’s <em>children.</em> Because elements can have children which are also elements, they form a tree of nodes which we call the <em>element tree</em>.</p>
<pre><code class="language-jsx">const list = (
  &lt;ul&gt;
    &lt;li&gt;Element 1&lt;/li&gt;
    &lt;li&gt;Element 2&lt;/li&gt;
  &lt;/ul&gt;
);
// transpiles to:
const list1 = createElement(&quot;ul&quot;, null,
  createElement(&quot;li&quot;, null, &quot;Element 1&quot;),
  createElement(&quot;li&quot;, null, &quot;Element 2&quot;),
);

console.log(list.props.children.length); // 2</code></pre>
<p>JSX parsers interpret the contents of elements which are not themselves elements as strings. However, just as with props, you can use curly brackets to interpolate JavaScript expressions into an element’s children. Besides elements and strings, almost every value in JavaScript can participate in an element tree. Numbers are rendered as strings, and the values <code>null</code>, <code>undefined</code>, <code>true</code> and <code>false</code> are erased, allowing you to render things conditionally using boolean expressions.</p>
<pre><code class="language-jsx">const el = &lt;div&gt;{&quot;a&quot;}{1 + 1}{true}{false}{null}{undefined}&lt;/div&gt;;
console.log(el.props.children); // [&quot;a&quot;, 2, true, false, null, undefined]
renderer.render(el, document.body);
console.log(document.body.innerHTML); // &lt;div&gt;a2&lt;/div&gt;</code></pre>
<p>Crank also allows arbitrarily nested iterables of values to be interpolated as children, so, for instance, you can insert arrays or sets of elements into element trees.</p>
<pre><code class="language-jsx">const arr = [1, 2, 3];
const set = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);
renderer.render(&lt;div&gt;{arr} {set}&lt;/div&gt;, document.body);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;123 abc&lt;/div&gt;&quot;</code></pre>
<h2>
				<a class="anchor" name="element-diffing" href="#element-diffing">Element Diffing</a>
			</h2><p>Crank uses the same “virtual DOM” diffing algorithm made popular by React, where we compare elements by tag and position to reuse DOM nodes. This approach allows you to write declarative code which focuses on producing the right tree, while the framework does the dirty work of managing state and mutating the DOM.</p>
<pre><code class="language-jsx">renderer.render(
  &lt;div&gt;
    &lt;span&gt;1&lt;/span&gt;
  &lt;/div&gt;,
  document.body,
);

const div = document.body.firstChild;
const span = document.body.firstChild.firstChild;
renderer.render(
  &lt;div&gt;
    &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;2&lt;/span&gt;
  &lt;/div&gt;,
  document.body,
);

console.log(document.body.firstChild === div); // true
console.log(document.body.firstChild.firstChild === span); // true</code></pre>
<p><strong>Note:</strong> The documentation avoids the terms “virtual DOM” or “DOM diffing” insofar as the core renderer can be extended to target multiple environments; instead, we use the terms “virtual elements” and “element diffing” to mean mostly the same thing.</p>
</div><footer class="footer"><div>Copyright © 2020 Brian Kim.</div><div>Distributed under the <a href="https://github.com/bikeshaving/crank/blob/master/LICENSE">MIT License</a>.</div><div>Logo by <a href="https://wstone.io">Will Stone</a> and <a href="https://github.com/pjdon">Paul Donchenko</a>.</div></footer></main><script src="/index.tsx.js"></script></body></html>